# M2: Rust C FFI Layer + WASM Build

## Goal

Build a thin `extern "C"` wrapper around Monty's Rust core. Produce both
a native shared library (`.dylib`/`.so`) and a WASM binary from the
**same source and lockfile**. Testable standalone with `cargo test` -- no
Dart needed.

## Risk Addressed

- **R3** (no existing C API) -- we build it here
- **R4** (poll/resume protocol) -- implemented and tested in Rust
- **R5** (Monty stability) -- does the pinned rev compile and work?
- **R2** (dependency skew) -- WASM built from same source as native

## Deliverable

- `native/` Rust crate producing:
  - `libdart_monty_native.dylib` (macOS) / `.so` (Linux)
  - `libdart_monty_native.a` (static, for iOS later)
  - `monty.wasm` + JS glue (WASM target)
- `native/include/dart_monty.h` -- C header for ffigen

## Usable For

Any language with C FFI (not just Dart). Validates that Monty's core API
can be safely exposed across a C boundary.

## Work Items

### 2.1 Rust Crate Setup

- [x] `native/Cargo.toml` with `edition = "2024"`
- [x] `native/rust-toolchain.toml` pinning stable Rust (>= 1.85.0)
- [x] `monty` dependency pinned to specific git rev `87f8f31`
- [x] `Cargo.lock` committed for reproducible builds
- [x] `crate-type = ["cdylib", "staticlib", "rlib"]`
- [x] `serde_json` dependency for JSON at FFI boundary

### 2.2 C API Implementation

Minimal API (< 20 functions). Poll/resume protocol:

```c
// Lifecycle
MontyHandle* monty_create(const char* code, const char* filename,
                          const char* inputs_json, const char* ext_fn_names_json);
void         monty_free(MontyHandle* h);

// Simple execution
MontyResultTag monty_run(MontyHandle* h, const char* inputs_json,
                         char** result_json, char** error_msg);

// Iterative execution
MontyProgressTag monty_start(MontyHandle* h, const char* inputs_json);
MontyProgressTag monty_resume(MontyHandle* h, const char* return_value_json);
MontyProgressTag monty_resume_with_error(MontyHandle* h, const char* error_msg);

// Read pending state
const char*  monty_pending_fn_name(MontyHandle* h);
const char*  monty_pending_fn_args_json(MontyHandle* h);

// Read completed state
const char*  monty_complete_result_json(MontyHandle* h);
int          monty_complete_is_error(MontyHandle* h);

// Snapshots
uint8_t*     monty_snapshot(MontyHandle* h, size_t* out_len);
MontyHandle* monty_restore(const uint8_t* data, size_t len);

// Resource limits
void monty_set_memory_limit(MontyHandle* h, size_t bytes);
void monty_set_time_limit_ms(MontyHandle* h, uint64_t ms);
void monty_set_stack_limit(MontyHandle* h, size_t depth);

// Memory management
void monty_string_free(char* ptr);
void monty_bytes_free(uint8_t* ptr, size_t len);
```

### 2.3 Verify "Resume with Error" Upstream

- [x] Check if Monty's `RunProgress` / `resume()` supports injecting exceptions
- [x] Supported: implemented `monty_resume_with_error` via `ExternalResult::Error`

### 2.4 Error Handling

- [x] `std::panic::catch_unwind` at every FFI entry point
- [x] All errors as C strings (caller frees with `monty_string_free`)
- [x] NULL handle checks on every function entry
- [x] OOM and timeout -> `MONTY_ERROR`

### 2.5 C Header

- [x] Hand-written `native/include/dart_monty.h`
- [x] Documents ownership semantics (who frees what)
- [x] Compatible with Dart `ffigen`

### 2.6 WASM Build

- [x] `cargo build --target wasm32-wasip1-threads` compiles successfully
- [x] Same `Cargo.lock` as native build (no version skew)
- [x] Output: `.wasm` binary
- [ ] Verify the WASM binary runs Python code correctly (via Node.js test) â€” deferred to M3 web spike

### 2.7 Tests

- [x] Unit test for each C API function (63 unit tests)
- [x] Smoke test: compile Python, run, get result
- [x] Iterative execution: start -> pending -> resume -> complete
- [x] Resume-with-error test
- [x] Snapshot round-trip (native)
- [x] Panic safety (invalid code, null pointers, non-UTF8, non-string panic payloads)
- [x] Resource limits (memory, time, stack)
- [x] 30 integration tests covering FFI error branches
- [x] Coverage: 90.34% (430/476 lines) via cargo-tarpaulin

### CI Expansion

When M2 completes, enable the following:

**CI workflow (`.github/workflows/ci.yaml`):**

- Uncomment the `build-native` job (matrix: `ubuntu-latest` and `macos-latest` only; exclude `windows-latest` -- Windows support is not part of M2)
- Add `rust-cargo-test` job: `cargo test` in `native/` on ubuntu-latest
- Add `rust-coverage` job: `cargo tarpaulin --out Xml` with >= 90% gate
- Add `dtolnay/rust-toolchain@stable` with `Swatinem/rust-cache@v2` for toolchain caching
- Add WASM build step: run `rustup target add wasm32-wasip1-threads` before `cargo build --release --target wasm32-wasip1-threads`

> **Note:** If Monty does not support "resume with error" (`monty_resume_with_error`), M2 must include a C-layer workaround (e.g., injecting a sentinel value that the Python side converts to an exception) before proceeding to M3.

**Pre-commit hooks (`.pre-commit-config.yaml`):**

- Add `cargo-fmt` hook: `cargo fmt --check` in `native/`
- Add `cargo-clippy` hook: `cargo clippy -- -D warnings` in `native/`
- Add `cargo-test` hook: `cargo test` in `native/`

## Quality Gate

```bash
cd native
cargo fmt --check
cargo clippy -- -D warnings
cargo test
cargo build --release
nm -gU target/release/libdart_monty_native.dylib | grep monty_

# WASM:
cargo build --release --target wasm32-wasip1-threads

# Coverage (cargo-tarpaulin or llvm-cov):
cargo tarpaulin --out Xml
# Coverage must be >= 90%
```

## Test Dependencies

| Tool | Purpose |
|------|---------|
| Rust stable (>= 1.85.0) | Compiler |
| `wasm32-wasip1-threads` target | WASM build |
| `cargo-tarpaulin` or `cargo-llvm-cov` | Coverage |
| Node.js (optional) | WASM smoke test runner |

## Automated Test Runner

```bash
tool/test_native.sh   # builds, tests, checks coverage, verifies WASM
```
