# M2: Rust C FFI Layer + WASM Build

## Goal

Build a thin `extern "C"` wrapper around Monty's Rust core. Produce both
a native shared library (`.dylib`/`.so`) and a WASM binary from the
**same source and lockfile**. Testable standalone with `cargo test` -- no
Dart needed.

## Risk Addressed

- **R3** (no existing C API) -- we build it here
- **R4** (poll/resume protocol) -- implemented and tested in Rust
- **R5** (Monty stability) -- does the pinned rev compile and work?
- **R2** (dependency skew) -- WASM built from same source as native

## Deliverable

- `native/` Rust crate producing:
  - `libdart_monty_native.dylib` (macOS) / `.so` (Linux)
  - `libdart_monty_native.a` (static, for iOS later)
  - `monty.wasm` + JS glue (WASM target)
- `native/include/dart_monty.h` -- C header for ffigen

## Usable For

Any language with C FFI (not just Dart). Validates that Monty's core API
can be safely exposed across a C boundary.

## Work Items

### 2.1 Rust Crate Setup

- [ ] `native/Cargo.toml` with `edition = "2024"`
- [ ] `native/rust-toolchain.toml` pinning stable Rust (>= 1.85.0)
- [ ] `monty` dependency pinned to specific git rev (NOT `branch = "main"`)
- [ ] `Cargo.lock` committed for reproducible builds
- [ ] `crate-type = ["cdylib", "staticlib"]`
- [ ] `serde_json` dependency for JSON at FFI boundary

### 2.2 C API Implementation

Minimal API (< 20 functions). Poll/resume protocol:

```c
// Lifecycle
MontyHandle* monty_create(const char* code, const char* filename,
                          const char* inputs_json, const char* ext_fn_names_json);
void         monty_free(MontyHandle* h);

// Simple execution
MontyResultTag monty_run(MontyHandle* h, const char* inputs_json,
                         char** result_json, char** error_msg);

// Iterative execution
MontyProgressTag monty_start(MontyHandle* h, const char* inputs_json);
MontyProgressTag monty_resume(MontyHandle* h, const char* return_value_json);
MontyProgressTag monty_resume_with_error(MontyHandle* h, const char* error_msg);

// Read pending state
const char*  monty_pending_fn_name(MontyHandle* h);
const char*  monty_pending_fn_args_json(MontyHandle* h);

// Read completed state
const char*  monty_complete_result_json(MontyHandle* h);
int          monty_complete_is_error(MontyHandle* h);

// Snapshots
uint8_t*     monty_snapshot(MontyHandle* h, size_t* out_len);
MontyHandle* monty_restore(const uint8_t* data, size_t len);

// Resource limits
void monty_set_memory_limit(MontyHandle* h, size_t bytes);
void monty_set_time_limit_ms(MontyHandle* h, uint64_t ms);
void monty_set_stack_limit(MontyHandle* h, size_t depth);

// Memory management
void monty_string_free(char* ptr);
void monty_bytes_free(uint8_t* ptr, size_t len);
```

### 2.3 Verify "Resume with Error" Upstream

- [ ] Check if Monty's `RunProgress` / `resume()` supports injecting exceptions
- [ ] If supported: implement `monty_resume_with_error`
- [ ] If NOT supported: file upstream issue, document workaround

### 2.4 Error Handling

- [ ] `std::panic::catch_unwind` at every FFI entry point
- [ ] All errors as C strings (caller frees with `monty_string_free`)
- [ ] NULL handle checks on every function entry
- [ ] OOM and timeout -> `MONTY_ERROR`

### 2.5 C Header

- [ ] Hand-written `native/include/dart_monty.h`
- [ ] Documents ownership semantics (who frees what)
- [ ] Compatible with Dart `ffigen`

### 2.6 WASM Build

- [ ] `cargo build --target wasm32-wasip1-threads` compiles successfully
- [ ] Same `Cargo.lock` as native build (no version skew)
- [ ] Output: `.wasm` binary + minimal JS loader
- [ ] Verify the WASM binary runs Python code correctly (via Node.js test)

### 2.7 Tests

- [ ] Unit test for each C API function
- [ ] Smoke test: compile Python, run, get result
- [ ] Iterative execution: start -> pending -> resume -> complete
- [ ] Resume-with-error test (or documented limitation)
- [ ] Snapshot round-trip (native)
- [ ] Panic safety (invalid code, null pointers, double-free)
- [ ] Resource limits (memory, time, stack)
- [ ] WASM smoke test (via Node.js or wasm-tools)

## Quality Gate

```bash
cd native
cargo fmt --check
cargo clippy -- -D warnings
cargo test
cargo build --release
nm -gU target/release/libdart_monty_native.dylib | grep monty_

# WASM:
cargo build --release --target wasm32-wasip1-threads

# Coverage (cargo-tarpaulin or llvm-cov):
cargo tarpaulin --out Xml
# Coverage must be >= 90%
```

## Test Dependencies

| Tool | Purpose |
|------|---------|
| Rust stable (>= 1.85.0) | Compiler |
| `wasm32-wasip1-threads` target | WASM build |
| `cargo-tarpaulin` or `cargo-llvm-cov` | Coverage |
| Node.js (optional) | WASM smoke test runner |

## Automated Test Runner

```bash
tool/test_native.sh   # builds, tests, checks coverage, verifies WASM
```
