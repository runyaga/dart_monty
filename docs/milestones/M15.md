# M15: Progress Serialization

## Goal

Expose `RunProgress::dump/load` and `ReplProgress::dump/load` for
serializing in-flight execution state. This enables suspending a Python
execution mid-run (at an external call boundary) and resuming it later —
across process restarts, device transfers, or cloud sync.

## Risk Addressed

- In-flight execution state is lost on process exit — long-running
  iterative workflows must restart from scratch
- No crash recovery for multi-step agent loops
- Cannot migrate execution between devices or environments

## Dependencies

- M7A (data model fidelity) — serialized progress should include
  kwargs, callId, excType, traceback
- M12 (REPL API) — for `ReplProgress::dump/load` (Run API progress
  serialization can ship independently)
- M2 (Rust C FFI layer) — new C functions

## Deliverables

### Platform Interface (`dart_monty_platform_interface`)

- `MontyPlatform.dumpProgress() -> Uint8List` — serialize the **in-flight
  paused execution state** (`RunProgress::dump`). Only valid when in
  `active` state with a pending external call. This is distinct from
  `snapshot()` (`MontyRun::dump`) which serializes compiled bytecode —
  `dumpProgress` captures the full VM heap, stack, and program counter
  at the pause point.
- `MontyPlatform.loadProgress(Uint8List bytes)` — restore from serialized
  in-flight state and return to `active` state ready for `resume()`
- For REPL: `MontyRepl.dumpProgress()` / `MontyRepl.loadProgress()`

### Native C FFI (`native/`)

- `monty_progress_dump(handle) -> (*const u8, usize)` — serialize
  `RunProgress` to bytes
- `monty_progress_restore(bytes, len) -> handle` — restore from bytes
- Equivalent for REPL progress

### JS Bridge (`dart_monty_wasm`)

- Serialize/restore through Worker protocol
- May use upstream `RunProgress.dump()`/`load()` JS bindings if available

## Work Items

### 15.1 Platform Interface

- [ ] `dumpProgress()` method on `MontyPlatform`
- [ ] `loadProgress()` factory/method on `MontyPlatform`
- [ ] Document valid states for dump (must be in pending state)
- [ ] Unit tests

### 15.2 Rust C FFI

- [ ] `monty_progress_dump(handle)` — serialize `RunProgress`
- [ ] `monty_progress_restore(bytes, len)` — restore `RunProgress`
- [ ] REPL variants (after M12)
- [ ] Rust unit tests

### 15.3 FFI Implementation

- [ ] `MontyFfi.dumpProgress()` — valid in `active` state
- [ ] `MontyFfi.loadProgress()` — creates new instance in `active` state
- [ ] State machine: loadProgress returns instance ready for `resume()`
- [ ] Mock-based unit tests (>= 90% coverage)
- [ ] Integration tests: dump mid-iteration, restore, resume to completion

### 15.4 WASM Implementation

- [ ] `MontyWasm.dumpProgress()` through JS bridge
- [ ] `MontyWasm.loadProgress()` through JS bridge
- [ ] Unit tests (>= 90% coverage)

### 15.5 Cross-Platform Portability

- [ ] Native progress dump -> WASM restore (and reverse)
- [ ] Verify serialized format is platform-independent
- [ ] Version compatibility: document format stability guarantees

### 15.6 Dartdoc

- [ ] Dartdoc comments on `dumpProgress()`, `loadProgress()`
- [ ] Document valid states and error conditions
- [ ] Code example: suspend mid-execution, persist to disk, restore later
- [ ] Document cross-platform portability guarantees (or limitations)
- [ ] `dart doc` generates cleanly with no warnings

## Demos Unlocked

- **Demo 6** (partial): Crash-recoverable execution, suspend/resume
  across app restarts (full Demo 6 also requires M7B print streaming)

### Validation Artifacts

No dedicated ladder tier for progress serialization. Validation is
through integration tests: dump mid-iteration, persist to disk/storage,
restore, resume to completion. Cross-platform round-trip tests (native
dump -> web restore and reverse) are the primary validation artifacts.

Demo 6 (Live Execution Streaming) partially depends on this milestone
for the crash-recovery and suspend/resume aspects. Full Demo 6 also
requires M7B (print streaming).

## Dart Layer

**Pure Dart** — no Flutter SDK dependency. Validated by integration
tests in `dart_monty_ffi` and `dart_monty_wasm`.

## Platform Support

| Platform | Status | Notes |
|----------|--------|-------|
| macOS (native FFI) | Full | RunProgress::dump/load through C FFI |
| Linux (native FFI) | Full | Same C API |
| Web (WASM/JS) | Full | Upstream JS RunProgress may support dump/load |
| Windows | After M9 | Same C API |
| iOS / Android | After M9 | Same C API |

**Platform-specific considerations:**
- Serialized bytes must be platform-independent (same format across
  native and web). This is a property of upstream monty's serialization,
  not something we control — but must be verified.
- Storage: where to persist serialized state is a host decision. On
  mobile, `path_provider` directories. On web, IndexedDB or localStorage.
  On desktop, filesystem. This milestone provides the serialization
  primitives; storage strategy is app-level.
- Size: serialized progress includes the full VM state (heap, stack,
  bytecode). Size grows with Python program complexity. Document expected
  sizes in benchmarks.

## Quality Gate

```bash
bash tool/test_m1.sh
bash tool/test_m3a.sh
bash tool/test_wasm.sh
bash tool/test_python_ladder.sh
```
