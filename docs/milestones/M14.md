# M14: Type Checking

## Goal

Expose upstream monty's bundled type checker (ty, formerly Red Knot by
Astral) for static analysis of Python code before execution. The host can
catch type errors without running the code — essential for AI agent loops
where LLM-generated code should be validated before execution.

## Risk Addressed

- No pre-execution validation — type errors only surface at runtime
- AI agent code generation loops waste execution cycles on malformed code
- No way to provide IDE-quality inline diagnostics in Flutter code editors
- No stub support for declaring external function signatures to the checker

## Dependencies

- Independent of M7A-M13 — type checking is a separate API that does not
  depend on the Run or REPL APIs
- M2 (Rust C FFI layer) — may need `monty-type-checking` crate linked in

## Deliverables

### Platform Interface (`dart_monty_platform_interface`)

- `MontyPlatform.typeCheck(code, {stubs, format})` method
- `TypeCheckResult` model: `hasErrors`, `diagnostics` list
- `TypeCheckDiagnostic` model: `message`, `filename`, `line`, `column`,
  `severity`, `code`
- `DiagnosticFormat` enum: `full`, `concise`, `json`, `github`

### Native C FFI (`native/`)

- `monty_type_check(code, stubs, format) -> *const c_char` — returns
  JSON diagnostics or null if clean
- Link `monty-type-checking` crate (verify it's included in pinned rev)

### JS Bridge (`dart_monty_wasm`)

- `Monty.typeCheck(prefixCode?)` already exists in upstream JS bindings
- Expose through Worker protocol

## Work Items

### 14.1 Platform Interface

- [ ] `typeCheck()` method on `MontyPlatform`
- [ ] `TypeCheckResult` model
- [ ] `TypeCheckDiagnostic` model
- [ ] `DiagnosticFormat` enum
- [ ] Unit tests for models and JSON parsing

### 14.2 Rust C FFI

- [ ] Verify `monty-type-checking` crate is available at pinned rev
- [ ] `monty_type_check(code, stubs_or_null, format) -> *const c_char`
- [ ] JSON output format for diagnostics
- [ ] Null return for clean code
- [ ] Rust unit tests

### 14.3 FFI Implementation

- [ ] `NativeBindings`: add type check C function signature
- [ ] `MontyFfi.typeCheck()` implementation
- [ ] Parse diagnostic JSON into `TypeCheckResult`
- [ ] Mock-based unit tests (>= 90% coverage)
- [ ] Integration tests: clean code, type errors, stub validation

### 14.4 WASM Implementation

- [ ] `MontyWasm.typeCheck()` through JS bridge `Monty.typeCheck()`
- [ ] Worker protocol for type check requests
- [ ] Unit tests (>= 90% coverage)

### 14.5 Ladder Runner Updates

- [ ] Native runner: parse `typeCheckExpected` from fixtures
- [ ] Native runner: call typeCheck() before execution when field is
      present, validate hasErrors and errorContains
- [ ] Web runner: mirror all native runner changes

### 14.6 Ladder Tests

- [ ] Tier 17 fixtures (type checking): IDs 210-215, remove xfail
- [ ] All fixtures pass on both native and web runners

### 14.7 Dartdoc

- [ ] Dartdoc comments on `typeCheck()`, `TypeCheckResult`,
      `TypeCheckDiagnostic`, `DiagnosticFormat`
- [ ] Document stub syntax for declaring external function signatures
- [ ] Code example: type-check → fix → re-check → execute loop
- [ ] Document integration with AI agent validation patterns
- [ ] `dart doc` generates cleanly with no warnings

## Ladder Tiers Unlocked

| Tier | Name | Fixture IDs | Count |
|------|------|-------------|-------|
| 17 | Type checking | 210-215 | 6 |

## Demos Unlocked

- **Demo 5:** Static Type Checking Before Execution (ty Integration)

### Validation Artifacts

The ladder fixtures (tier 17) are built and passing as part of this
milestone. Demo application (5 — Static Type Checking) is identified
as a showcase target but detailed demo design — including web vs desktop
platform choice, UI treatment, and user flow — is deferred to a separate
visioning/planning process after milestone reorganization.

## Dart Layer

**Pure Dart** — no Flutter SDK dependency. Validated by the ladder
runner (CLI + web).

## Platform Support

| Platform | Status | Notes |
|----------|--------|-------|
| macOS (native FFI) | Full | `monty-type-checking` crate linked into native lib |
| Linux (native FFI) | Full | Same C API |
| Web (WASM/JS) | Full | `Monty.typeCheck()` already in upstream JS bindings |
| Windows | After M9 | Same C API |
| iOS / Android | After M9 | Same C API |

**Platform-specific considerations:**
- Native: The `monty-type-checking` crate must be linked into
  `libdart_monty_native`. This may increase binary size. Verify the
  crate is available at the pinned monty rev (87f8f31).
- Web: `Monty.typeCheck(prefixCode?)` is already exposed in the JS NAPI
  bindings. Worker protocol just needs a new message type.
- Binary size: Type checking includes the ty type checker engine. If
  binary size is a concern on mobile, consider making it opt-in at
  build time (feature flag in Cargo.toml).

## Design Notes

### Stub Support

The type checker accepts optional "prefix code" (stubs) that declares
signatures for external functions. This lets the checker validate calls
like `fetch(123)` against `def fetch(url: str) -> str: ...` without
needing a real implementation. The Dart API should accept stubs as a
simple string parameter.

### Diagnostic Formats

Upstream supports multiple output formats. The Dart API should default
to JSON (structured, parseable) but allow the host to request other
formats for display purposes:

- `full` — multi-line with source context and carets
- `concise` — single-line per diagnostic
- `json` — structured, machine-readable
- `github` — GitHub Actions annotation format

## Quality Gate

```bash
bash tool/test_platform_interface.sh
bash tool/test_ffi.sh
bash tool/test_wasm.sh
bash tool/test_python_ladder.sh
```
