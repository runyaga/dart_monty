# M3: Pure Dart FFI Package + Web Spike + Snapshot Portability

## Goal

Two pure Dart packages (no Flutter):
1. `dart_monty_ffi` -- load native library, run Python from any Dart program
2. Web viability spike -- prove Dart WASM + JS interop loads Monty in a browser

Plus: validate snapshot portability between native and WASM.

**This phase contains the GO/NO-GO decision for web support.**

## Risk Addressed

- **R1** (web WASM/WASI viability) -- validated with pure Dart, no Flutter
- **R2** (snapshot portability) -- tested between native and WASM

## Deliverables

- `packages/dart_monty_ffi` -- pure Dart package, works in CLI/server
- `spike/web_test/` -- minimal Dart WASM program proving web viability
- Snapshot round-trip test: native <-> WASM

## Usable For

- Dart CLI tools that execute Python sandboxed code
- Dart servers running LLM-generated Python
- Standalone Dart scripts
- Go/no-go evidence for web investment

## Work Items

### 3.1 ffigen Configuration

- [ ] `packages/dart_monty_ffi/ffigen.yaml` pointing to `native/include/dart_monty.h`
- [ ] Generated bindings in `lib/src/generated/dart_monty_bindings.dart`
- [ ] `.gitignore` excludes generated file (regenerated via `dart run ffigen`)
- [ ] `tool/generate_bindings.sh` script

### 3.2 High-Level Dart FFI Wrapper

- [ ] `Monty` class implementing `MontyPlatform` from platform_interface
- [ ] Library loading: `DynamicLibrary.open()` with platform-appropriate path
- [ ] JSON encode inputs -> C string -> FFI call -> C string -> JSON decode
- [ ] `NativeFinalizer` attached to `Monty` for leak prevention
- [ ] Pointer lifecycle: allocate with `malloc`, free with `monty_*_free()`

### 3.3 Iterative Execution in Dart

- [ ] `start()` -> `monty_start()`, check tag, return `MontyProgress`
- [ ] `MontyPending`: read fn name + args from handle
- [ ] `resume()` -> `monty_resume()` with JSON-encoded return value
- [ ] `resumeWithError()` -> `monty_resume_with_error()`
- [ ] Caller controls the loop (not inside the package)

### 3.4 Snapshots

- [ ] `snapshot()` returns `Uint8List` (copy from native buffer, free original)
- [ ] `Monty.restore()` creates new handle from `Uint8List`

### 3.5 Web Viability Spike (GO/NO-GO)

Pure Dart, no Flutter. Uses `dart compile wasm`.

- [ ] `spike/web_test/main.dart` -- Dart program using `dart:js_interop`
- [ ] `spike/web_test/index.html` -- loads Monty WASM (from M2) + Dart WASM
- [ ] Serve with COOP/COEP headers:
  ```
  Cross-Origin-Opener-Policy: same-origin
  Cross-Origin-Embedder-Policy: require-corp
  ```
- [ ] Compile: `dart compile wasm spike/web_test/main.dart -o spike/web_test/app.wasm`
- [ ] Verify: Python code executes in browser via Dart WASM -> JS interop -> Monty WASM
- [ ] **GO**: Web works -> proceed to M4 (Dart WASM package) and M6 (Flutter web)
- [ ] **NO-GO**: Document blocker, re-scope to native-only

### 3.6 Snapshot Portability Test

- [ ] Create snapshot via Dart FFI (native library)
- [ ] Restore snapshot in browser (Monty WASM, same source)
- [ ] Verify same result on both paths
- [ ] If NOT portable: document as limitation, remove cross-platform snapshot claims

### 3.7 Cross-Path Parity Test

Run **identical Python code** through both native FFI and web WASM paths,
assert **identical results**. This is the true end-to-end integration test
proving both paths are functionally equivalent.

Test suite (`test/cross_path_parity_test.dart` or equivalent scripts):

- [ ] **Arithmetic**: `2 + 2` -> `4` on both paths
- [ ] **String ops**: `"hello " + "world"` -> `"hello world"` on both paths
- [ ] **Collections**: `[1,2,3]`, `{"a": 1}` -> identical JSON on both paths
- [ ] **Builtins**: `len([1,2,3])` -> `3` on both paths
- [ ] **External function**: register `add(a, b)`, call from Python, verify
      poll/resume produces same result on both paths
- [ ] **Resource limits**: set memory limit, run allocating code, verify both
      paths return the same error
- [ ] **Error handling**: invalid syntax, runtime error -> same error structure
      on both paths
- [ ] **Snapshot parity**: create snapshot on native, restore on WASM (and
      reverse), verify execution continues identically

Implementation: a shared JSON test fixture file defining inputs and expected
outputs, consumed by both the native Dart test runner and the browser test
runner.

### 3.8 Python Compatibility Ladder

A **growing test suite** of increasingly complex Python code. Each tier
must pass on both native FFI and WASM before the milestone is complete.
New tiers are added in later milestones as Monty gains features.

The ladder lives in `test/fixtures/python_ladder/` as numbered JSON files.
Each file defines: `code`, `inputs`, `expected_output`, `expected_error`
(if any), and `tier`. A shared test runner loads all fixtures at or below
the current tier and executes them on both paths.

#### Tier 1 -- Expressions (M3 gate)

| # | Code | Expected |
|---|------|----------|
| 1 | `2 + 2` | `4` |
| 2 | `"hello " + "world"` | `"hello world"` |
| 3 | `3.14 * 2` | `6.28` |
| 4 | `True and not False` | `True` |
| 5 | `10 // 3` | `3` |
| 6 | `10 % 3` | `1` |
| 7 | `2 ** 10` | `1024` |
| 8 | `f"value is {1 + 2}"` | `"value is 3"` |

#### Tier 2 -- Variables and Collections (M3 gate)

| # | Code | Expected |
|---|------|----------|
| 9 | `x = 5\nx * 2` | `10` |
| 10 | `[1, 2, 3][1]` | `2` |
| 11 | `{"a": 1, "b": 2}["b"]` | `2` |
| 12 | `len([1, 2, 3, 4])` | `4` |
| 13 | `list(range(5))` | `[0, 1, 2, 3, 4]` |
| 14 | `sorted([3, 1, 2])` | `[1, 2, 3]` |
| 15 | `{1, 2, 2, 3}` | `{1, 2, 3}` |
| 16 | `(1, "two", 3.0)` | `(1, "two", 3.0)` |

#### Tier 3 -- Control Flow (M3 gate)

| # | Code | Expected |
|---|------|----------|
| 17 | `x = 0\nfor i in range(5): x += i\nx` | `10` |
| 18 | `[i**2 for i in range(4)]` | `[0, 1, 4, 9]` |
| 19 | `"even" if 4 % 2 == 0 else "odd"` | `"even"` |
| 20 | `x = 10\nwhile x > 0: x -= 3\nx` | `-2` |
| 21 | `{k: v for k, v in [("a", 1), ("b", 2)]}` | `{"a": 1, "b": 2}` |
| 22 | `[x for x in range(10) if x % 2 == 0]` | `[0, 2, 4, 6, 8]` |

#### Tier 4 -- Functions (M3 gate)

| # | Code | Expected |
|---|------|----------|
| 23 | `def add(a, b): return a + b\nadd(3, 4)` | `7` |
| 24 | `def fib(n):\n  if n <= 1: return n\n  return fib(n-1) + fib(n-2)\nfib(10)` | `55` |
| 25 | `def greet(name="world"): return f"hello {name}"\ngreet()` | `"hello world"` |
| 26 | `def mul(*args):\n  r = 1\n  for a in args: r *= a\n  return r\nmul(2,3,4)` | `24` |
| 27 | `nums = [1,2,3]\nlist(map(lambda x: x*2, nums))` | `[2, 4, 6]` |
| 28 | `def make_adder(n):\n  def adder(x): return x + n\n  return adder\nmake_adder(5)(3)` | `8` |

#### Tier 5 -- Error Handling (M3 gate)

| # | Code | Expected |
|---|------|----------|
| 29 | `try:\n  1/0\nexcept ZeroDivisionError:\n  "caught"` | `"caught"` |
| 30 | `try:\n  int("abc")\nexcept ValueError as e:\n  str(e)` | error string |
| 31 | invalid syntax `def` | `MontyException` with source location |

#### Tier 6 -- External Functions (M3 gate)

| # | Code | Expected |
|---|------|----------|
| 32 | register `fetch(url)`, Python calls `fetch("https://example.com")` | poll/resume returns `MontyPending("fetch", ["https://example.com"])` |
| 33 | resume with `"response body"` -> Python receives it | `"response body"` |
| 34 | resume with error -> Python catches exception | `MontyException` |

#### Future Tiers (added when Monty supports them)

| Tier | Feature | Gate |
|------|---------|------|
| 7 | Classes and instances | M4+ (when Monty adds class support) |
| 8 | Async/await | M4+ (when Monty async is stable) |
| 9 | Dataclasses | M4+ |
| 10 | Generators and iterators | M4+ |
| 11 | Match statements | M4+ |
| 12 | Stdlib modules (json, sys) | M4+ |

Each new tier is added to the fixture files and the gate script
automatically picks them up. If a tier fails on WASM but passes on
native (or vice versa), that's a bug -- both paths must be identical.

#### Automation

- [ ] `test/fixtures/python_ladder/` directory with numbered JSON fixtures
- [ ] `test/fixtures/python_ladder/tier_01_expressions.json`, etc.
- [ ] Shared test runner: loads all fixtures, runs on both paths, diffs
- [ ] `tool/test_python_ladder.sh`:
  1. Build native + WASM
  2. Run all tiers on native FFI (`dart test --tags=ladder`)
  3. Run all tiers in browser (headless Chrome)
  4. Assert: every fixture produces identical output on both paths
- [ ] New tiers added by simply dropping a JSON file -- no code changes

### 3.9 Automated Integration Tests

Integration tests require the native library and WASM binary built from M2.

- [ ] `tool/test_ffi.sh`:
  1. `cd native && cargo build --release`
  2. `cd packages/dart_monty_ffi`
  3. `DYLD_LIBRARY_PATH=... dart test --tags=integration`
- [ ] `tool/test_web_spike.sh`:
  1. Build Monty WASM (from M2)
  2. `dart compile wasm spike/web_test/main.dart`
  3. Start local server with COOP/COEP headers (Node.js or Python)
  4. Run headless Chrome, capture console output
  5. Assert expected result
- [ ] `tool/test_cross_path_parity.sh`:
  1. Build native library + WASM binary
  2. Run parity test suite on native (Dart FFI, `dart test --tags=parity`)
  3. Run parity test suite in browser (headless Chrome)
  4. Diff outputs -- must be identical
- [ ] `tool/test_snapshot_portability.sh`:
  1. Run native Dart program that creates + serializes a snapshot
  2. Run browser test that restores the snapshot
  3. Compare results

### 3.10 Unit Tests (mock-based, no native lib)

- [ ] `Monty` class logic with mock FFI
- [ ] JSON encoding/decoding edge cases
- [ ] Pointer lifecycle (mock allocator)
- [ ] Error propagation

## Quality Gate

```bash
# Unit tests (no native lib):
cd packages/dart_monty_ffi
dart pub get
dart format --set-exit-if-changed .
dart analyze --fatal-infos
dart test --coverage=coverage
# Coverage must be >= 90%

# Integration tests (requires M2 built):
tool/test_ffi.sh                   # native FFI end-to-end
tool/test_web_spike.sh             # web viability end-to-end
tool/test_cross_path_parity.sh     # same Python -> same result on native AND WASM
tool/test_python_ladder.sh         # tiers 1-6: increasingly complex Python on both paths
tool/test_snapshot_portability.sh   # cross-platform snapshot round-trip
```

## Test Dependencies

| Tool | Purpose |
|------|---------|
| Dart SDK | Compiler, test runner, `dart compile wasm` |
| Native library from M2 | FFI integration tests |
| WASM binary from M2 | Web spike |
| Node.js or Python | Local COOP/COEP dev server for web spike |
| Chrome (headless) | Browser test runner for web spike |

## Decision Point

After M3 completes, the team reviews web spike results:

| Outcome | Action |
|---------|--------|
| Web spike passes | Proceed to M4 (Dart WASM) and M6 (Flutter web) |
| Web spike fails (fixable) | Investigate, document fix, retry |
| Web spike fails (fundamental) | Drop web phases, native-only project |
