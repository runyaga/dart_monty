# M12: REPL API

## Goal

Expose the upstream `MontyRepl` API — a stateful Python session where
variables, functions, and imports persist across multiple `feed()` calls.
This is the largest new API surface since M1 and unlocks interactive
consoles, notebook-style execution, and incremental AI agent tool loops.

## Risk Addressed

- Cannot build interactive Python consoles — every `run()` starts fresh
- AI agent loops must re-send all context on each invocation
- Educational tools cannot let students build up state incrementally
- No way to detect incomplete input (multi-line blocks)

## Dependencies

- M7A (data model fidelity) — REPL errors benefit from full tracebacks,
  excType, and script_name
- M8 (Rich Type Bridge) — REPL return values should be fully typed
- M2 (Rust C FFI layer) — new C functions for REPL lifecycle

## Deliverables

### Platform Interface (`dart_monty_platform_interface`)

- `MontyRepl` abstract class with `feed()`, `dump()`, `load()`, `dispose()`
- `ReplProgress` — mirrors `MontyProgress` but returns the REPL for reuse
- `ReplContinuationMode` enum: `Complete`, `IncompleteImplicit`, `IncompleteBlock`
- `detectContinuationMode(String source)` utility function
- REPL supports external functions (iterative `feed` with pause/resume)

### Native C FFI (`native/`)

New C functions:

- `monty_repl_create(script_name, inputs_json, ext_fns, tracker, print) -> handle`
  (note: `script_name` must be passed through for traceback attribution)
- `monty_repl_feed(handle, code) -> progress_tag`
- `monty_repl_start(handle, code) -> progress_tag` (iterative with ext fns)
- `monty_repl_snapshot(handle) -> *const u8`
- `monty_repl_restore(bytes, len) -> handle`
- `monty_repl_free(handle)`
- `monty_detect_continuation_mode(code) -> int`
- Progress accessors reused from Run API (kwargs, callId, etc.)

### JS Bridge (`dart_monty_wasm`)

- `MontyRepl` JS class: `create`, `feed`, `dump`, `load`
- Worker protocol: `{type: "repl_create"}`, `{type: "repl_feed", code: "..."}`, etc.
- Reuse existing progress/resume protocol for iterative REPL execution

### Implementations

- `MontyReplFfi` — FFI implementation of `MontyRepl`
- `MontyReplWasm` — WASM implementation of `MontyRepl`
- Both support session snapshot/restore

## Work Items

### 12.1 Platform Interface

- [ ] `MontyRepl` abstract class (accepts optional `scriptName` for
      traceback attribution, matching M7A's `run()`/`start()` pattern)
- [ ] `ReplProgress` sealed class (complete, pending, error variants)
- [ ] `ReplContinuationMode` enum
- [ ] `detectContinuationMode()` utility
- [ ] `MontyRepl.feed()` returns `MontyObject` (simple) or `ReplProgress` (iterative)
- [ ] `MontyRepl.dump()` / `MontyRepl.load()` for session persistence
- [ ] `MontyRepl.dispose()` lifecycle
- [ ] Unit tests for all models

### 12.2 Rust C FFI

- [ ] New C functions for REPL lifecycle (create, feed, start, free)
- [ ] REPL snapshot/restore (dump, load)
- [ ] Continuation mode detection
- [ ] Error recovery: REPL state preserved after `ReplStartError`
- [ ] Rust unit tests
- [ ] `cargo clippy -- -D warnings` clean

### 12.3 FFI Implementation

- [ ] `NativeBindings`: add REPL C function signatures
- [ ] `MontyReplFfi` implementing `MontyRepl`
- [ ] Session state machine: created -> active -> disposed
- [ ] Error recovery: REPL survives `feed()` errors
- [ ] Mock-based unit tests (>= 90% coverage)
- [ ] Integration tests: multi-step sessions, error recovery, snapshot

### 12.4 JS Bridge & WASM Implementation

- [ ] Worker: `MontyRepl` JS class lifecycle
- [ ] `MontyReplWasm` implementing `MontyRepl`
- [ ] Session persistence through Worker
- [ ] Unit tests (>= 90% coverage)

### 12.5 Flutter Plugin Integration

- [ ] `dart_monty_desktop`: REPL through Isolate
- [ ] `dart_monty_web`: REPL through Worker
- [ ] Integration tests

### 12.6 Ladder Runner Updates

- [ ] Native runner: parse `replSteps` field from fixtures
- [ ] Native runner: create MontyRepl, feed each step sequentially,
      validate per-step expected/error
- [ ] Web runner: mirror all native runner changes
- [ ] Runner handles snapshot/restore steps within replSteps

### 12.7 Ladder Tests

- [ ] Tier 12 fixtures (REPL sessions): IDs 160-168, remove xfail
- [ ] All fixtures pass on both native and web runners
- [ ] JSONL parity verified

### 12.8 Dartdoc

- [ ] Dartdoc comments on `MontyRepl`, `ReplProgress`, `ReplContinuationMode`
- [ ] Document REPL session lifecycle (create → feed → feed → ... → dispose)
- [ ] Code examples: interactive console, agent loop, error recovery
- [ ] Document continuation mode detection for multi-line input handling
- [ ] `dart doc` generates cleanly with no warnings

## Ladder Tiers Unlocked

| Tier | Name | Fixture IDs | Count |
|------|------|-------------|-------|
| 12 | REPL sessions | 160-168 | 9 |

## Demos Unlocked

- **Demo 1:** Interactive Python Console

### Validation Artifacts

The ladder fixtures (tier 12) are built and passing as part of this
milestone. Demo application (1 — Interactive Python Console) is
identified as a showcase target but detailed demo design — including
web vs desktop platform choice, UI treatment, and user flow — is
deferred to a separate visioning/planning process after milestone
reorganization.

## Dart Layer

**Pure Dart** (core). The REPL API is implemented in
`dart_monty_platform_interface`, `dart_monty_ffi`, and
`dart_monty_wasm` without Flutter. Flutter plugin integration
(`dart_monty_desktop`, `dart_monty_web`) is additive — plumbing REPL
through Isolate/Worker. Validated by the ladder runner (CLI + web).
Interactive Playground is a separate Flutter showcase artifact.

## Platform Support

| Platform | Status | Notes |
|----------|--------|-------|
| macOS (native FFI) | Full | New REPL C functions, Isolate-based in Flutter |
| Linux (native FFI) | Full | Same C API |
| Web (WASM/JS) | Full | Upstream JS `MontyRepl` class, Worker-based |
| Windows | After M9 | Same C API |
| iOS / Android | After M9 | Same C API |

**Platform-specific considerations:**
- Native: REPL session lives in a native handle. For Flutter desktop,
  the Isolate holds the session — multiple `feed()` calls route through
  the same Isolate to the same native handle.
- Web: REPL session lives in the Worker's `MontyRepl` JS instance.
  The Worker maintains session state across `feed` messages.
- Memory: REPL sessions accumulate heap state. Long-lived sessions on
  memory-constrained platforms (mobile, web) should be monitored.

## Design Notes

### feed() vs start() in REPL

Upstream provides two paths:

- `MontyRepl::feed(&mut self, code, print)` — simple, synchronous.
  Blocks until code completes. Cannot handle external function calls.
- `MontyRepl::start(self, code, print)` — consuming, iterative. Returns
  `ReplProgress` which may be `FunctionCall` requiring resume.

Dart should expose both: `feed()` for simple evaluation, `start()` for
code that may call external functions.

### Error Recovery

`MontyRepl::start()` returns `Result<ReplProgress, Box<ReplStartError>>`
where `ReplStartError` preserves the REPL state. The Dart implementation
must extract the REPL from the error and keep the session alive. This is
critical — errors must not destroy the session.

## Quality Gate

```bash
bash tool/test_platform_interface.sh
bash tool/test_ffi.sh
bash tool/test_wasm.sh
bash tool/test_python_ladder.sh
bash tool/test_cross_path_parity.sh
```
