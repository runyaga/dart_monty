# M8: Rich Type Bridge

## Goal

Preserve Python type identity through the C FFI and JS bridges. Upstream
monty distinguishes tuples from lists, sets from lists, bytes from int
arrays, and dataclasses from dicts. The current bridge collapses all of
these into generic Dart `List` and `Map` types. M8 adds typed Dart
wrappers and updates both bridges to recognize upstream JSON type tags.

## Risk Addressed

- Tuple/list conflation — immutable tuples indistinguishable from mutable
  lists after round-tripping
- Set deduplication lost — sets become lists, duplicates may reappear
- Bytes inefficiency — `b"..."` serialized as JSON integer arrays (4x bloat)
- Dataclass metadata lost — `name`, `type_id`, `frozen`, `field_names`
  all discarded
- NamedTuple metadata lost — `type_name` and `field_names` discarded
- BigInt truncation — values exceeding i64 range serialized as strings
  but not parsed back as BigInt
- Path type lost — `pathlib.Path` collapses to plain string

## Dependencies

- M7A (data model fidelity) — model changes should be stabilized first
- M2 (Rust C FFI layer)
- M4 (WASM package)

## Deliverables

### New Dart Types (`dart_monty_platform_interface`)

- `MontyValue` — sealed class hierarchy for typed Python values
- `MontyTuple` — wraps `List<Object?>`, distinguishes from `MontyList`
- `MontySet` — unordered, deduplicated collection
- `MontyFrozenSet` — immutable unordered collection
- `MontyBytes` — wraps `Uint8List`, efficient binary data
- `MontyNamedTuple` — preserves `typeName` and `fieldNames`
- `MontyDataclass` — preserves `name`, `typeId`, `frozen`, `fieldNames`
- `MontyPath` — wraps path string with type marker
- `MontyBigInt` — wraps Dart `BigInt` for arbitrary-precision integers
- `MontyRepr` — non-serializable display string
- `MontyCycle` — circular reference marker

### Bridge Updates

Both C FFI and JS bridges must recognize upstream JSON type tags:

| Upstream JSON | Dart Type |
|--------------|-----------|
| `{"$tuple": [...]}` | `MontyTuple` |
| `{"$set": [...]}` | `MontySet` |
| `{"$frozenset": [...]}` | `MontyFrozenSet` |
| `{"$bytes": "base64..."}` or `{"$bytes": [...]}` | `MontyBytes` |
| `{"$namedtuple": {"type_name": ..., "field_names": [...], "values": [...]}}` | `MontyNamedTuple` |
| `{"$dataclass": {"name": ..., "field_names": [...], "attrs": {...}, "frozen": bool}}` | `MontyDataclass` |
| `{"$path": "..."}` | `MontyPath` |
| `{"$repr": "..."}` | `MontyRepr` |
| `{"$cycle": {"heap_id": N, "repr": "..."}}` | `MontyCycle` |
| String matching big integer pattern | `MontyBigInt` |

### Backward Compatibility

Existing code that accesses `MontyResult.value` as `Map`/`List`/`String`
must continue to work. The typed wrappers should implement appropriate
Dart interfaces (`Iterable`, `Map`, etc.) or provide `.toList()`,
`.toMap()` convenience methods.

## Work Items

### 8.1 Platform Interface Types

- [ ] `MontyValue` sealed class hierarchy
- [ ] `MontyTuple`, `MontySet`, `MontyFrozenSet` collection types
- [ ] `MontyBytes` wrapping `Uint8List`
- [ ] `MontyNamedTuple` with `typeName`, `fieldNames`, index + name access
- [ ] `MontyDataclass` with `name`, `typeId`, `frozen`, `fieldNames`, field access
- [ ] `MontyPath`, `MontyBigInt`, `MontyRepr`, `MontyCycle`
- [ ] JSON deserialization: detect `$`-prefixed type tags
- [ ] JSON serialization: emit `$`-prefixed tags for round-trip fidelity
- [ ] Unit tests for all types and JSON round-trips

### 8.2 Rust C FFI Updates

- [ ] Verify upstream JSON includes type tags (may need Rust-side changes
      to serialization if current C FFI strips them)
- [ ] If C FFI currently flattens types: update `monty_complete_result_json`
      to preserve `$tuple`, `$set`, `$bytes`, etc.
- [ ] Bytes: consider binary output path (`monty_complete_result_bytes`)
      to avoid JSON-encoding large byte arrays
- [ ] Rust unit tests

### 8.3 FFI Implementation

- [ ] `MontyFfi`: update JSON parsing to produce typed `MontyValue` objects
- [ ] Backward-compatible: existing tests that check `value as int` still work
- [ ] Mock-based unit tests (>= 90% coverage)
- [ ] Integration tests with native library

### 8.4 JS Bridge Updates

- [ ] Verify upstream JS bindings preserve type tags in output JSON
- [ ] `MontyWasm`: update JSON parsing to produce typed `MontyValue` objects
- [ ] Unit tests (>= 90% coverage)

### 8.5 Ladder Runner Updates

- [ ] Native runner: parse `expectedTypeTag` from fixtures
- [ ] Native runner: check Dart runtime type of result value against
      expected type wrapper (MontyTuple, MontySet, MontyBytes, etc.)
- [ ] Web runner: mirror all native runner changes

### 8.6 Ladder Tests

- [ ] Tier 10 fixtures (rich types): IDs 130-144, remove xfail
- [ ] All fixtures pass on both native and web runners
- [ ] JSONL parity verified

### 8.7 Dartdoc

- [ ] Dartdoc comments on all new public types (`MontyValue` hierarchy)
- [ ] Document type tag mapping in package-level dartdoc
- [ ] Code examples in dartdoc showing type checking patterns
- [ ] `dart doc` generates cleanly with no warnings

## Ladder Tiers Unlocked

| Tier | Name | Fixture IDs | Count |
|------|------|-------------|-------|
| 10 | Rich types | 130-144 | 15 |

## Demos Unlocked

- **Demo 8:** Structured Data Round-Trip (dataclass, namedtuple, set)
- **Demo 10:** Binary Data Processing Pipeline (bytes as Uint8List)

### Validation Artifacts

The ladder fixtures (tier 10) are built and passing as part of this
milestone. Demo applications (8, 10) are identified as showcase targets
but detailed demo design — including web vs desktop platform choice,
UI treatment, and user flow — is deferred to a separate
visioning/planning process after milestone reorganization.

## Dart Layer

**Pure Dart** — no Flutter SDK dependency. JSON type tag parsing is
in Dart-level code. Validated by the ladder runner (CLI + web).

## Platform Support

| Platform | Status | Notes |
|----------|--------|-------|
| macOS (native FFI) | Full | C FFI must preserve JSON type tags |
| Linux (native FFI) | Full | Same C API |
| Web (WASM/JS) | Full | JS bindings already use type tags — verify passthrough |
| Windows | Deferred | Covered by M9 |
| iOS / Android | Deferred | Covered by M9 |

**Platform-specific considerations:**
- Native: Rust C FFI serialization may currently strip type tags.
  Investigate whether the `serde_json` serialization path in the C
  wrapper preserves `$tuple`/`$set`/`$bytes` or flattens them.
- Web: Upstream JS `MontyComplete.output` likely preserves tags. Verify
  that the Worker serialization step doesn't strip them.
- Bytes: Native path could use a binary transfer (`monty_complete_result_bytes`)
  to avoid JSON encoding. Web path may need base64 in Worker messages.

## Quality Gate

```bash
bash tool/test_m1.sh
bash tool/test_m3a.sh
bash tool/test_wasm.sh
bash tool/test_python_ladder.sh
bash tool/test_cross_path_parity.sh

# Dartdoc:
cd packages/dart_monty_platform_interface && dart doc .
```
