# M13: Async / Futures

## Goal

Support Python `async`/`await` and `asyncio.gather` by handling the
`RunProgress::ResolveFutures` variant. The Dart host acts as the event
loop — Python yields pending futures, the host resolves them concurrently,
and execution resumes. This enables parallel external calls from
sandboxed Python code.

## Risk Addressed

- Python `async`/`await` code fails silently or hangs — the VM yields
  `ResolveFutures` but dart_monty doesn't recognize it
- No concurrent external calls — each external function is resolved
  one at a time even when Python code uses `asyncio.gather`
- Agent workflows cannot parallelize API calls or I/O

## Dependencies

- **M7A required** — `call_id` correlation is foundational for matching
  future results to their Python awaitables
- M2 (Rust C FFI layer) — new progress variant + resume protocol

## Deliverables

### Platform Interface (`dart_monty_platform_interface`)

- `MontyResolveFutures` — new `MontyProgress` variant with
  `pendingCallIds` (`List<int>`)
- `MontyPlatform.resolveFutures(Map<int, Object?> results)` — resume
  with a map of call_id -> resolved value
- `MontyPlatform.resolveFuturesWithErrors(Map<int, Object?> results,
  Map<int, String> errors)` — resume with mixed results and errors
- `ExternalResult` enum/class: `Return(value)`, `Error(message)`,
  `Future(callId)` — mirrors upstream `ExternalResult`
- Updated iterative loop documentation showing futures handling

### Native C FFI (`native/`)

- Detect `RunProgress::ResolveFutures` tag
- `monty_pending_future_call_ids(handle) -> *const c_char` (JSON array)
- `monty_resume_futures(handle, results_json) -> progress_tag`
- Support `ExternalResult::Future` return from host during sync calls

### JS Bridge (`dart_monty_wasm`)

- Handle `ResolveFutures` progress from Worker
- `MontySnapshot.resume` with future results
- Worker protocol for future resolution

## Work Items

### 13.1 Platform Interface

- [x] `MontyResolveFutures` progress variant
- [x] `resolveFutures()` method on `MontyPlatform`
- [x] `ExternalResult` type (Return, Error, Future)
- [x] Allow `resume()` to return `ExternalResult::Future` to create futures
- [x] Unit tests for new types and resume protocol

### 13.2 Rust C FFI

- [x] Detect `ResolveFutures` tag in progress dispatch
- [x] `monty_pending_future_call_ids` accessor
- [x] `monty_resume_futures` with JSON results map
- [x] Support `ExternalResult::Future` in resume path
- [x] Rust unit tests

### 13.3 FFI Implementation

- [x] `MontyFfi`: recognize `ResolveFutures` progress
- [x] Construct `MontyResolveFutures` from native accessors
- [x] `resolveFutures()` implementation
- [x] Host returning `Future` from sync call -> VM creates awaitable
- [x] Mock-based unit tests (>= 90% coverage)
- [x] Integration tests: single await, gather, error propagation

### 13.4 WASM Implementation

- [x] `MontyWasm`: recognize `ResolveFutures` from Worker
- [x] `resolveFutures()` through JS bridge (stubbed — NAPI-RS does not expose FutureSnapshot)
- [x] Unit tests (>= 90% coverage)

### 13.5 Ladder Runner Updates

- [ ] Native runner: parse `asyncResumeMap` from fixtures
- [ ] Native runner: return ExternalResult::Future from sync calls
      when asyncResumeMap is present
- [ ] Native runner: handle ResolveFutures progress variant, resume
      with mapped values from asyncResumeMap
- [ ] Web runner: mirror all native runner changes

### 13.6 Ladder Tests

- [ ] Tier 13 fixtures (async/futures): IDs 170-175, remove xfail
- [ ] All fixtures pass on both native and web runners
- [ ] JSONL parity verified

### 13.7 Dartdoc

- [x] Dartdoc comments on `MontyResolveFutures`, `ExternalResult`
- [x] Document the async execution flow: sync call -> return Future ->
      VM yields ResolveFutures -> host resolves -> VM resumes
- [x] Code examples showing `asyncio.gather` with concurrent host resolution
- [x] Document call_id correlation pattern
- [ ] `dart doc` generates cleanly with no warnings

## Ladder Tiers Unlocked

| Tier | Name | Fixture IDs | Count |
|------|------|-------------|-------|
| 13 | Async / futures | 170-175 | 6 |

## Demos Unlocked

- **Demo 2:** Concurrent Async HTTP with Python await

### Validation Artifacts

The ladder fixtures (tier 13) are built and passing as part of this
milestone. Demo application (2 — Concurrent Async HTTP) is identified
as a showcase target but detailed demo design — including web vs desktop
platform choice, UI treatment, and user flow — is deferred to a separate
visioning/planning process after milestone reorganization.

## Dart Layer

**Pure Dart** — no Flutter SDK dependency. Changes touch
`dart_monty_platform_interface`, `native/`, `dart_monty_ffi`, and
`dart_monty_wasm`. Validated by the ladder runner (CLI + web).

## Platform Support

| Platform | Status | Notes |
|----------|--------|-------|
| macOS (native FFI) | Full | New progress variant + resume protocol in C FFI |
| Linux (native FFI) | Full | Same C API |
| Web (WASM/JS) | Full | Worker handles ResolveFutures, main thread resolves |
| Windows | After M9 | Same C API |
| iOS / Android | After M9 | Same C API |

**Platform-specific considerations:**
- Native: Future resolution happens on the Dart side (Isolate or main
  thread). The Python VM is blocked in the native handle until
  `resolveFutures()` is called.
- Web: Worker yields `ResolveFutures` message. Main thread Dart code
  resolves futures (e.g. via `http` package), then sends results back
  to Worker. Natural fit for browser async patterns.
- Concurrency: `asyncio.gather` enables the host to make parallel HTTP
  calls. On web this uses browser fetch parallelism; on native it uses
  Dart's `Future.wait`.

## Design Notes

### Execution Flow

```text
1. Host calls monty.start(code, externalFunctions: ['fetch'])
2. Python: result = await fetch("url")
   -> VM yields FunctionCall(name="fetch", args=["url"], call_id=0)
3. Host: return ExternalResult::Future (instead of resolving immediately)
   -> VM registers future for call_id 0, continues executing
4. Python: asyncio.gather(fetch("a"), fetch("b"))
   -> VM yields FunctionCall for each, host returns Future for each
5. Python: all coroutines blocked on awaits
   -> VM yields ResolveFutures(pending_call_ids=[0, 1, 2])
6. Host: resolves all three concurrently
   -> monty.resolveFutures({0: "resp0", 1: "resp1", 2: "resp2"})
7. VM resumes, Python code continues with resolved values
```

### Error Propagation

When a future resolution fails, the host can include errors in the
results map. The Python side sees a `RuntimeError` (or appropriate
exception) when it tries to `await` the failed future.

## Quality Gate

```bash
bash tool/test_m1.sh
bash tool/test_m3a.sh
bash tool/test_wasm.sh
bash tool/test_python_ladder.sh
bash tool/test_cross_path_parity.sh
```
